### What are namespaces and why are they needed ?
- Namespaces are used to organize a set of related objects.
- It is also used to create globally unique types so that a type with a specific name in one namespace does not clash with a type with the same name in another namespace.

### Explain the differences between a Value type and a Reference type ?
- Value Types
	- Directly contain the data in memory
		- Unless part of an object where they are allocated inline on the heap.
	- Assigning a value type variable to another variable will copy the value.
	- Cannot be assigned have a `null` value because they always have a default value. 
- Reference Types
	- A reference to the value is stored in the allocated memory as opposed to the value itself.
	- Reference is stored on the Stack but the contents are stored on the Heap.
	- Assigning a reference type variable to another variable will not create a copy of the contents but only a copy of the reference

### What are some examples of Value types and Reference types ?
- Value Types
	- Predefined data types (Int, Boolean, Char, etc)
	- Structs
	- Enums
- Reference Types
	- Classes
	- Objects
	- Arrays
	- Indexers
	- Interfaces

### What is the difference between a `struct` and a `class` ?
- `struct` is a **value type** where as a `class` is a **reference type**
- `class` is passed by reference whilst a `struct` is passed by value.
- See answer on "Explain the differences between a Value type and a Reference type".

### When to use a `struct` over a `class` and vice-versa ?
- Use mostly classes
- Use struct when
	- It is *immutable*.
	- It logically represents a single value, similar to primitive types.
	- It has an instance size smaller than 16 bytes.
	- It will not have to be boxed frequently.
- Use classes for more complex objects that require behaviour, encapsulation, and inheritance, such as entities in an object-oriented design.

### What is the difference between `int` and `Int32` ?
- There is no difference
- `Int32` is a type provided by the .NET framework whereas `int` is an alias name in C# that references `Int32`.

### What is a `record` ?
- Same as a `class` but with functionality autogenerated:
	- Implements `IEquatable`
	- Overrides
		- `ToString()`
		- `GetHashCode()`
		- `Clone()`
	- Enforced *immutability* using [[C#/Records/init keyword|init]].

### What is a `record struct` and why would you use it ?
- [[record struct]]

### What are the differences between `class` and `record` in C# ?
- `record` is *immutable* (but can be mutable), `class` is not
- `record` uses value comparison, `class` uses reference comparison.

### When to use `class` vs `record` vs `struct` ?
- [[Records vs Classes vs Structs]]

### How do you implement a generic action in WebAPI ?
- It’s not possible, as the WebAPI runtime needs to know the method signatures in advance.

### What are the various methods provided to `System.Object` derived classes/types and what is there purpose ?
###### ToString
- Returns a string that represents the current object
###### Equals(object)
- It determines whether the two objects represent the same object reference.
###### GetHashCode
- A hash function that is used to quickly generate a number (hash code) that corresponds to the value of an object.
	- For reference types, the value corresponds to the object's reference
	- For structs, the value corresponds to either all the fields (fast approach) or only the first non-static field (slow) in the struct (see answer below called "How does the default implementation for `GetHashCode` work for a `struct`").
	- More info [here](https://vkontech.com/gethashcode-pitfalls/)
- Mainly used for putting an object into a hash table.
- Useful for comparing an object to another other object for equality.
	- Only if overridden with an implementation that compares each of the properties.
###### Finalize
- Release unmanaged resources
- Called by the garbage collector
###### GetType
- GetType gets the runtime type of an instance.
###### ReferenceEquals
- Static equivalent of `Equals` but takes two parameters.
###### MemberwiseClone
- Creates a shallow copy by creating a new object, and then copying the non-static fields of the current object to the new object.

### How does the default implementation for `GetHashCode` work for a `struct` ?
- It has two versions of the algorithm, *fast* and *slow*. 
- Fast compares all members of the struct using *bitwise* equality (xors 4 bytes at a time)
- A struct can use the fast approach if:
	- No reference type members
	- No padding between the fields
		- Padding is empty space in a structure value, created when the JIT compiler aligns the fields. 
		- There's padding in a struct that contains `bool` and `int` but no padding when it contains `int` and `int`.
- Examples of fast value types are `Point` and `Size`.
- Otherwise, the slow approach is used which only compares the first non-static field. 

### How does the default implementation for `GetHashCode` work for a `class` ?
- Computes a hash value based on the objects *reference*.

### Why should you be careful when using objects as dictionary keys ?
- All hash-based collections assume that an object’s hash value does not change while it is in use as a key in the collection. If a key’s hash code were to change while it was in a collection, some unpredictable and confusing consequences could follow. 
- It is *not* common practice to use a *mutable* object like a `List` as a key in a `HashMap`.

### Why is it important to override `GetHashCode` when `Equals` method is overridden ?
- Because hash based collections rely on both the `GetHashCode` and `Equals` methods to perform their operations in cases where the key is an object.
- If you override Equals() method, then you need to override the GetHashCode() method to match it's logic:
	- If `Equals()` returns true for two objects, then `GetHashCode()` should also return the same value for the two objects.
	- If `GetHashCode()` is equal, *it is not necessary for them to be the same (this is a collision), and `Equals` will be called to see if it is a real equality or not*.
- It is not true for the reverse however, ==just because two objects have the same `GetHashCode` result, it does not mean they are equal.==

### How does a hash-based containers operate where the key is an object ?
- Let's say we are retrieving an object from the container. 
- `GetHashCode` is used to find the bucket in the container to which the object belongs.
- If there is more than one object in that bucket (due to hash collisions), then `Equals` is used to compare the references to find the exact object in that bucket.
- If the two objects have the same hash code, *that does not mean they are the same, it could be a collision.*
- Therefore when `GetHashCode` returns the same value, than the `Equals` method is called to see if it is a real equality or not.
- `Equals` is only ever called when the `GetHashCode` method returns the same value.
- See questions about `GetHashCode` above to understand what value is returned for a `class` and `struct`

### What are `IEnumerable` and `IQueryable` and how do they differ ?
- Key difference is that `IEnumerable` is executed in memory, where as `IQueryable` executes on the server.
- `IEnumerable` is an interface in the `System.Collections` namespace that defines a method called `GetEnumerator` for obtaining an enumerator, which allows readonly iteration over a collection.
	- Queries using `IEnumerable` execute on the *client side*. This means all data is loaded into memory from the data source before query operations like filtering or sorting are applied.
	- Suitable for small to medium datasets (so they can fit into main memory).
- `IQueryable`, part of the `System.Linq` namespace, extends `IEnumerable` and is tailored for LINQ queries against a specific data source such as databases or web services.
	- `IQueryable` enables the conversion of LINQ queries into a domain-specific query language, such as SQL for databases. This allows the query to be processed on the server side.
	- Suitable for large datasets or databases.

### When to use `IEnumerable` over `IQueryable` and vice-versa ?
- `IEnumerable`:
	- In-memory data collections.
	- Small to medium datasets.
- `IQueryable`:
	- Large datasets or databases.
	- Querying data from remote sources (web service, database).
	- Performance optimization (executing all or most of the query on the server instead of locally using IEnumerable)

### What is the purpose of the `Dispose` method of the `IDisposable()` interface ?
- The `Dispose` method is used to release unmanaged resources *explicitly*. 
- It's typically implemented in classes that use unmanaged resources such as file handles, database connections, or network sockets. 
- By calling Dispose, developers can release these resources *immediately*, ensuring timely cleanup and preventing resource leaks.

### What is the purpose of the `Finalize()` method ?
- The Finalize method is used for releasing unmanaged resources as part of the [[Garbage Collection#Garbage Collection Process|garbage collection process]]. 
- It's invoked by the garbage collector before reclaiming memory occupied by an object. 

### Why use the `Dispose()` method over the `Finalize()` method to free resources ?
- The problem with Finalize is that it's called by the GC which is non-deterministic meaning we don't know when or if it's going to be called.
- The Dispose() method however makes it possible to support deterministic cleanup which allows the caller to release any resources *sooner*.

### What is Reflection API and where is it used ?
- Provides the capability to inspect a classes constructs dynamically.
- With Reflection you can load a class dynamically from an Assembly, test whether a given type has a specific member, and even create code dynamically.
- Several important tools make use of reflection to enable their working. 
	- Unit test frameworks use reflection to identify test classes and methods marked with the necessary attributes.

### What is the difference between `typeof`, `GetType` and `is` ?
###### typeof 
- Takes a type name (which you specify at *compile time*).
- Must be exactly the type (not child class of type)
###### GetType 
- Gets the *runtime* type of an instance.
- Must be exactly the type (not child class of type)
###### is
- Returns true if an instance is of the object's exact type or any of it's derived types.

### Are Strings Mutable or Immutable ? 
- String are Immutable
- The String class internally uses an array to store the contents of the string
- This array is a fixed size and any time an edit is made, a new array is created and the changed contents are copied over.

### What are non-nullable types in C# ?
- [[Non-nullable Type]]