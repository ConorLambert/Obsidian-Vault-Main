### What are namespaces and why are they needed ?
- Namespaces are used to organize a set of *related* objects.
- It is also used to create globally unique types so that a type with a specific name in one namespace does not clash with a type with the same name in another namespace.

### Explain the differences between a Value type and a Reference type ?
- Value Types
	- Directly contain the data in memory
		- Unless part of an object where they are allocated inline on the heap.
	- Assigning a value type variable to another variable will copy the value.
	- Passed by value
	- Cannot be assigned have a `null` value because they always have a default value. 
- Reference Types
	- A reference to the value is stored in the allocated memory as opposed to the value itself.
	- Reference is stored on the Stack but the contents are stored on the Heap.
	- Passed by reference
	- Assigning a reference type variable to another variable will not create a copy of the contents but only a copy of the reference

### Can a Value type be assigned null ?
- No it always has a default value

### Are Arrays a Value type or a Reference type ?
- Value Type

### Are Enums a Value type or a Reference type ?
- Value Type

### Are Indexers a Value type or a Reference type ?
- Reference Type

### Is DateTime a Value type or a Reference type ?
- Value Type

### What is the difference between a `struct` and a `class` ?
- `struct` is a **value type** where as a `class` is a **reference type**
- See answer on "Explain the differences between a Value type and a Reference type".

### When to use a `struct` over a `class` and vice-versa ?
- Use mostly classes
- Use struct when
	- +++ It is *immutable*.
	- It logically represents a single value, similar to primitive types.
	- It has an instance size smaller than 16 bytes.
	- It will not have to be boxed frequently.
- Use classes for more complex objects that require behaviour, encapsulation, and inheritance, such as entities in an object-oriented design.

### What is the difference between `int` and `Int32` ?
- There is no difference
- `Int32` is a type provided by the .NET framework whereas `int` is an alias name in C# that references `Int32`.

### What is a `record` ?
- Same as a `class` but with functionality autogenerated:
	- Implements `IEquatable`
	- Overrides
		- `ToString()`
		- `GetHashCode()`
		- `Clone()`
	- Enforced *immutability* using [[C#/Records/init keyword|init]].

### What is a `record struct` and why would you use it ?
- Record that is a value type
- [[record struct#Purpose of `record struct`|Purpose]]

### What are the differences between `class` and `record` in C# ?
- `record` is *immutable* (but can be mutable), `class` is not
- `record` uses value comparison, `class` uses reference comparison.

### When to use `class` vs `record` vs `struct` ?
- [[Records vs Classes vs Structs#Guidelines|Guidelines]]

### How do you implement a generic action in WebAPI ?
- It’s not possible, as the WebAPI runtime needs to know the method signatures in advance.

### How does the default implementation for `GetHashCode` work for a `struct` ?
- It has two versions of the algorithm, *fast* and *slow*. 
- Fast compares all members of the struct using *bitwise* equality (xors 4 bytes at a time)
- A struct can use the fast approach if:
	- No reference type members
	- No padding between the fields
		- +++ Padding is empty space in a structure value, created when the JIT compiler aligns the fields. 
		- There's padding in a struct that contains `bool` and `int` but no padding when it contains `int` and `int`.
- Examples of fast value types are `Point` and `Size`.
- Otherwise, the slow approach is used which only compares the first non-static field. 

### How does the default implementation for `GetHashCode` work for a `class` ?
- Computes a hash value based on the objects *reference*.

### What are the various methods provided to `System.Object` derived classes/types and what is there purpose ?
###### ToString
- Returns a string that represents the current object
###### Equals(object)
- It determines whether the two objects represent the same object reference.
###### GetHashCode
- A hash function that is used to quickly generate a number (hash code) that corresponds to the value of an object.
	- For reference types, the value corresponds to the object's reference
	- For structs, the value corresponds to either all the fields (fast approach) or only the first non-static field (slow) in the struct (see answer below called "How does the default implementation for `GetHashCode` work for a `struct`").
	- More info [here](https://vkontech.com/gethashcode-pitfalls/)
- Mainly used for putting an object into a hash table.
- Useful for comparing an object to another other object for equality.
	- Only if overridden with an implementation that compares each of the properties.
###### ReferenceEquals
- Static equivalent of `Equals` but takes two parameters.
###### MemberwiseClone
- Creates a shallow copy by creating a new object, and then copying the non-static fields of the current object to the new object.
###### +++ Finalize
- Release unmanaged resources
- Called by the garbage collector
###### +++ GetType
- GetType gets the runtime type of an instance.


### Why should you be careful when using objects as dictionary keys ?
- All hash-based collections assume that an object’s hash value does not change while it is in use as a key in the collection. If a key’s hash code were to change while it was in a collection, some unpredictable and confusing consequences could follow. 

### Why is it important to override `GetHashCode` when `Equals` method is overridden but not vice-versa ?
- Because hash based collections rely on both the `GetHashCode` and `Equals` methods to perform their operations in cases where the key is an object.
- If you override Equals() method, then you need to override the GetHashCode() method to match it's logic:
	- If `Equals()` returns true for two objects, then `GetHashCode()` should also return the same value for the two objects.
- It is not true for the reverse however. If `GetHashCode()` is equal, *it is not necessary for them to be the same (this is a collision), and `Equals` will be called to see if it is a real equality or not*.

### How does a hash-based containers operate where the key is an object ?
- Let's say we are retrieving an object from the container. 
- `GetHashCode` is used to find the bucket in the container to which the object belongs.
- If the two objects have the same hash code, *that does not mean they are the same, it could be a collision.*
- Therefore when `GetHashCode` returns the same value, than the `Equals` method is called to see if it is a real equality or not.

### What are `IEnumerable` and `IQueryable` and how do they differ ?
- Key difference is that `IEnumerable` is executed in memory, where as `IQueryable` executes at the data source (e.g. database).
- `IEnumerable` is an interface that declares a `GetEnumerator` method that returns an `IEnumerator` which allows for iterating over a read-only collection.
- `IQueryable` is part of the `System.Linq` namespace and extends the `IEnumerable` interface. It provides a number of methods for manipulating data.

### When to use `IEnumerable` over `IQueryable` and vice-versa ?
- `IEnumerable`:
	- In-memory data collections.
	- Small to medium datasets.
- `IQueryable`:
	- Large datasets or databases.
	- Querying data from remote sources (web service, database).
	- Performance optimization (executing all or most of the query at the source instead of locally using IEnumerable)

### What is the purpose of the `Dispose` method of the `IDisposable()` interface ?
- The `Dispose` method is used to release unmanaged resources *explicitly*. 
- It's typically implemented in classes that use unmanaged resources such as file handles, database connections, or network sockets. 
- By calling Dispose, developers can release these resources *immediately*, ensuring timely cleanup and preventing resource leaks.

### What is the purpose of the `Finalize()` method ?
- The Finalize method is used for releasing unmanaged resources as part of the [[Garbage Collection#Garbage Collection Process|garbage collection process]]. 
- It's invoked by the garbage collector before reclaiming memory occupied by an object. 

### Why use the `Dispose()` method over the `Finalize()` method to free resources ?
- The problem with Finalize is that it's called by the GC which is non-deterministic meaning we don't know when or if it's going to be called.
- The Dispose() method however makes it possible to support deterministic cleanup which allows the caller to release any resources *sooner*.

### What is the Reflection API and where is it used ?
- Provides the capability to inspect a classes constructs dynamically.
- With Reflection you can
	- Test whether a given type has a specific member
	- Load a class dynamically from an Assembly
	- Create code dynamically
- Several important tools make use of reflection to enable their working. 
	- Unit test frameworks use reflection to identify test classes and methods marked with the necessary attributes.

### What is the difference between `typeof`, `GetType` and `is` ?
###### typeof 
- Takes a type name (which you specify at *compile time*).
- Often used in conjunction with `GetType()`
	- `support.GetType() == typeof(Security)`
- The above expression will only return true if `support` is exactly of type `Security` and not a derived type.
###### GetType 
- Gets the *runtime* type of an instance.
###### is
- Returns true if an instance is of the object's exact type or any of it's derived types.

### Are Strings Mutable or Immutable ? 
- String are Immutable
- The String class internally uses an array to store the contents of the string
- This array is a fixed size and any time an edit is made, a new array is created and the changed contents are copied over.

### What are non-nullable types in C# ?
- [[Non-nullable Type]]