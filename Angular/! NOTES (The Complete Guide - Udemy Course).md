#### What is the purpose of the Angular CLI
- Angular code needs to be converted to native javascript code before it can run in the browser.
- The conversion also includes transpiling TypeScript into JavaScript.
- The conversion happens anytime an Angular application is run during development or deployment purposes.
- The CLI does many other tasks like setting up projects and running tests.

#### How an Angular App Gets Loaded and Started
- The **index.html** file in an Angular project acts as the *single page* that is core to the SPA functionality.
- **index.html** references the root component via the **app-root** tag seen inside the index.html file.
- This root component and **index.html** are automatically generated by the CLI when setting up the project.
- The root components default name is **AppComponent** but this can be changed (not recommended).
- When an Angular project runs in the browser, the CLI first needs to translate the Angular code into native javascript code so the browser can understand it.
- If you run your Angular project and open the **View Page Source** window in the browser, you can see that none of the Angular code is deployed. Instead, you have the content of the **index.html** file plus a list of imported JavaScript files at the end.
- These JavaScript files are generated by the CLI and contain the JavaScript translation of our Angular code.
- During the build process performed by the CLI, the first code to be executed in our Angular project is the code inside the **main.ts** file. The main line of code here is the call to **bootstrapModule**. This takes an **NgModule** type as argument. Internally, the **bootstrapModule** function will check the **bootstrap** property of the **NgModule** type passed in. 
- The **bootstrap** array property of **NgModule** declares the root component that is referenced in the **index.html** file. *This bootstrap array basically lists the components that should be known to the CLI at the point of time that it analyses the **index.html** file*. So the NgModule object passed in to the **bootstrapModule** function should be the root module of the project and that root module should declare what component in that module (via the bootstrap array property) will be the root component used by the **index.html** (don't forget, modules can contain multiple components so we need to declare which one of those components is the root component). 

#### .ts Extension Imports into TypeScript files
- We don't add the .ts extension when importing functionality (components, directives, modules, etc) from one TypeScript file into another.
- Webpack automatically adds this extension when bundling our project.

#### Multiple Bootstrapped Components
- The **bootstrap** array property can contain more then one component.
- Likewise, the **index.html** page can contain more then one root component.
- *The components are rendered on screen in the order they are defined in the bootstrap array property and not in the order they are defined in the index.html*

#### Databinding
- Databinding refers to the communication between the HTML template and the TypeScript code of the same component.

#### String Interpolation
- Indicated by curly braces {{}} in the template (HTML).
- Used to output text in the template
###### Rules
- *Only expressions that can resolve to a string are valid*.
- Function calls are valid as long as they return a value that is a string or can be converted to a string.
- Ternary expressions are valid
- Multi-line expressions or block expressions are *invalid* e.g. if statements, for loops, etc.

#### Property Binding
- Indicated by square brackets [] in the template (HTML).
- Used to bind properties of a HTML element e.g. the `disabled` property of a button element.
- Also used to bind properties of a directive or component.
###### Rules
- The expression inside the square brackets must be the type of the property it is bound to or can be implicitly converted to the type the property it is bound to. For example, the `disabled` property expects a boolean value but any other type that can be implicitly converted to a boolean value will also work.
	- NOTE: Be careful using non-boolean types for a boolean property as the rules of Truthy and Falsey come into play which can cause confusion.
- Function calls are also valid but the return type must follow the same rules as outlined in the point above.

#### Event Binding
- Indicated by parentheses () in the template (HTML).
- Used to bind events of a HTML element e.g. the `click` event of a button element.
- Also used to bind events of a directive or component.
- Similar to property binding but binds to events instead
	- Another difference is the event is generally bound to a method call in the TypeScript code.
- Many events emit additional data about the event that can be captured by passing the `$event` to the method we care calling.
###### Rules
- Any event of a HTML element can be bound.
- If the event is bound to a method, then this method must exists in the TypeScript code of the same component. For example, you can't bind to a method of an object that is referenced in the TypeScript code, the method must be defined in the TypeScript code itself
	- A workaround here is to call the referenced objects method inside a method defined in the TypeScript code.
- Inline expressions are valid. For example you can update the property of component instance right in the expression of the `click` event handler without the need to wrap this simple expression in a function inside the component instance:
	`<button (click)="counter=counter+1">INC</button>`
- The following is also valid (but not recommended):
	`<button (click)="showDetail=true; number=2; calculate()">Click me</button>`

#### Two-Way Databinding
- Indicated by a combination of square brackets and parentheses [()] in the template (HTML).
- Combination of **Property Binding** and **Event Binding**
###### Rules
- Two-Way Databinding does not apply to any property or event provided to by a HTML element. It only works on certain properties that have been extended by Angular e.g. `ngModel`. 
	- This [section](https://angular.io/guide/two-way-binding#how-two-way-binding-works) describes how a component is to be structured in order for Two-Way Databinding to work. 
		- It involves naming your `@Output` property based on your `@Input` property but with the word "Change" appended. For example, if your `@Input` property is called `size` then your `@Output` property should be called `sizeChange`

#### Directives
- Directives are classes that add additional behaviour to elements in your Angular applications.
- Built in directives are prefixed with the letters `ng`, for example `ngStyle`, `ngIf`, `ngModel`, etc.

#### Directive Types
###### Component:
- Components are technically directives just with an added template.
###### Structural:
- Change the DOM layout by adding and removing DOM elements.
- When structural directives are applied they generally are prefixed by an asterisk, `*`, such as `*ngIf`. Angular transforms the asterisk in front of a structural directive into an `ng-template` that surrounds the host element and its descendants.
###### Attribute:
- Change the appearance or behaviour of an element, component, or another directive. Examples of attribute directives are `ngClass`, `ngStyle`, etc.

#### Should I Create a Component
- Will the component needs its own business logic.
- Will it trigger a routing action.

#### File and Folder Structure
- There are different approaches to file and folder structure
- Medium [article](https://medium.com/@shijin_nath/angular-right-file-structure-and-best-practices-that-help-to-scale-2020-52ce8d967df5) on an example file structure

#### Property Alias
- You can use another name to bind to an `@Input` property.
- This is done by adding an argument to the Input decorator like so
	- `@Input('someName') name: string` 
- That means the calling component must bind to `someName` instead of `name`.
###### Use Cases:
- It's a simple way to prevent your code from breaking if another dev ever changes that variable name. If the variable changes in the component, you don't need to change it in your template because it's using the alias. 
	- I remember the name changing was a pain point in previous projects.

#### View Encapsulation
- The following explains how Angular implements View Encapsulation so that the browser will apply the component styles only to that component:
	- For every component, Angular creates a unique attribute.
	- This unique attribute is appended to every HTML element of that component. 
	- Each selector in the CSS file for that component is updated so that the unique attribute is prepended to the selector declaration.

#### Template Reference
	<input #serverElement />
	@ViewChild('serverNameInput') serverNameInput: ElementRef;
- Get access to every property of the referenced element.
- Used in the TypeScript code to manipulate that element.
- If the template reference element is not available on component initialisation (e.g. could be wrapped in an \***ngIf**) then **ViewChild** will not work. Instead, you can pass the template reference to a method that is called in the template:
	![[Pasted image 20240118181011.png|500]]

#### @Output Property Naming Conventions
###### Goals:
- Avoid naming collisions with Angular or with vanilla JavaScript.
- Expressiveness so your future self or anyone else will know exactly what the event signifies.
- Make it easy to perform `Find` and `Replace` operations.
###### Solution:
- Never use a property name that Angular or the native web uses.
	- A good tool to avoid collisions is called `codelyzer` and in particular the `no-output-named-after-standard-event` property.
- Don't prefix EventEmitters with `on` as per Angular [guidelines](https://angular.io/guide/styleguide#dont-prefix-output-properties)
- Use past-participles i.e. the past tense of a verb, which often ends in `ed` in English.
	- Therefore, name EventEmitters with things like click**ed** instead of click. 
		- This also avoids naming collisions with Angular events as Angular uses the word click.
###### EventEmitter Handlers:
- A handlers is a method that is called when the event is emitted. This is generally defined in the parent component.
- This should have the same name as the EventEmitter but prefixed with the word `on`.
- For example, if the EventEmitter is called `messageSendSucceeded`, then the event handler should be called `onMessageSendSucceeded`.
```html
<app-email-form  
(messageSendSucceeded)="onMessageSendSucceeded($event)"  
(messageSendFailed)="onMessageSendFailed($event)"  
[email]="user.email"  
>  
</app-email-form>
```


## Lifecycle Hook (395-397)
#### `ngOnChanges` called before `ngOnInit`
- `ngOnChanges` is called before `ngOnInit` in the lifecycle process.

#### Extra Change Detection Cycle in Development Mode
- Angular has one extra cycle in development mode
- This is why you see `ngDoCheck` execute twice during development. 

#### `@ViewChild` and `ngAfterViewInit` hook.
- Use the `ngAfterViewInit` hook to write any component initialization code that uses the references injected by `@ViewChild`.
- Depending on the situation, the template references _might_ already be present on `ngOnInit()`, but we shouldn't count on it.
- This is because the View has not been rendered until this stage.

#### Lifecycle Hooks & Sequence
1. Constructor
2. ngOnChanges
	- Called when data-bound input properties change
	- The `SimpleChange` parameter holds the details of this change.
1. ngOnInit
2. ngDoCheck
	- Called during every change detection run
3. ngAfterContentInit
	- Called after Angular *projects* external content into the component's view.
4. ngAfterContentChecked
	- Called after Angular *checks* the content projected into the component.
5. ngAfterViewInit
	- Called after Angular initialises the component's views and child views
6. ngAfterViewChecked
	- Called after Angular *checks* the component's views and child views
7. ngOnDestroy
	- Called just before Angular destroys the directive/component.

#### Best Practice: Use `Renderer2` instead of just `ElementRef`
- The `Renderer2` class is an abstraction provided by Angular in the form of a service that allows to manipulate elements of your app without having to touch the DOM directly. 
- *This is the recommended approach because it then makes it easier to develop apps that can be rendered in environments that don’t have DOM access, like on the server, in a web worker or on native mobile.*
- Better to pass `ElementRef` into `Renderer2` and let `Renderer2` find the element.

```typescript
@Directive({
	selector: '[appBetterSelector]'
})
export class BetterSelectorDirective {
	constructor(private elementRef: ElementRef, private renderer: Renderer2) {}

	ngOnInit() {
		this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'blue')
	}
}
```

#### Tip on @HostBinding and @HostListener
- `HostBinding('value') myValue;` is exactly the same as `[value]="myValue"`
- `HostListener('click') myClick(){ }` is exactly the same as `(click)="myClick()"`

#### @Input Setter Method
- @Input setter method is triggered every time the @Input changes


## ???
#### ???
- ???